---
title: "Project"
output: html_notebook

---

Installation and Package loading

```{r}
library("ggplot2")
library('dplyr')
library('Rlab')
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or
by pressing *Ctrl+Alt+I*.

ALL THE FOLLOWING FUNCTIONS, UP TO AND FUSION SHOULD ALSO HAVE A TABLE EITHER AS INPUT, OR WORK ON A TABLE THAT IS CHANGED THROUGH THEIR CALL.

#Population Change Function to model population development in one year,
given parameters:

  N0 - Number of adults in the patch 
  b - Growth rate 
  l_max - maximum population that may survive in the habitat 
  patch - on which patch we are working

OR: we only take Patch as input, we have pre-defined the parameters for
each patch, and do a short look up, and use the last row of the patch X
column to than compute the new population
Output:
  N - new number of individuals

```{r Population Change}

  Population <- function(N0=10, b=0.001, l_max=1.4, years=50) {
  ADLT           <- matrix(1, ncol=1, nrow=N0)     
  
colnames(ADLT) <- "patch"                        
  sumStats      <- NULL                            
  sumStats      <- rbind(sumStats, c(0,N0))        
  
  for(t in 1:years){
    
    N       <- nrow(ADLT)                           
    Fec     <- l_max / (1 + b * N)                      
    indFec  <- rpois(n=N, lambda=Fec)               
    OFF     <- matrix(1, ncol=1, nrow= sum(indFec)) 
    colnames(OFF) <- "patch"                        
    ADLT     <- OFF  
    
  #if (t >= quota_T) {
   #   harvesting <- min(quota_N, nrow(ADLT))
    #  ADLT <- ADLT[sample(1:nrow(ADLT), size = nrow(ADLT)-harvesting, replace = F),] 
      
     # }
    sumStats <- rbind(sumStats, c(t,nrow(ADLT))) 
}
    colnames(sumStats) <- c("year", "size")
  return(sumStats)

}

```
#Dispersal Function to model dispersal in one patch in one year given
parameters:
  
  disp_prob - probability to change the patch

Output: two matrices of one row, both showing the 
```{r Dispersal}
randomly_drawn<-function(n,p){
  return(sum(rbern(n,p)))
}

dispersal<-function(matrix1, matrix2, parameter1,parameter2, year, random=FALSE, method="default", ...){
  last_row1<-tail(matrix1,n=1)
  last_row2<-tail(matrix2,n=1)
  
  disp_prob1<-case_when(method=="even" ~ parameter1$dispersal_prob,
                        method=="population_dependent" ~ parameter1$l_max-parameter1$l_max / (1 + parameter1$b * parameter1$wanderlust*last_row1[,"overall"]),
                        TRUE ~ 0.1)
  
  disp_prob2<-case_when(method=="even" ~ parameter2$dispersal_prob,
                        method=="population_dependent" ~ parameter2$l_max-parameter2$l_max / (1 + parameter2$b * parameter2$wanderlust*last_row1[,"overall"]),
                        TRUE ~ 0.1)
  
  if(random){
    d_1to2<-unlist(lapply(last_row1[,c("AA","AB","BB")],randomly_drawn,p=disp_prob1))
    d_2to1<-unlist(lapply(last_row2[,c("AA","AB","BB")],randomly_drawn, p=disp_prob2))
  }
  else{  
    d_1to2<-round(last_row1[,c("AA","AB","BB")]*disp_prob1)
    d_2to1<-round(last_row2[,c("AA","AB","BB")]*disp_prob2)
    }
  
  change_1<-c(d_2to1-d_1to2,sum(d_2to1)-sum(d_1to2))
  change_2<-c(d_1to2-d_2to1,sum(d_1to2)-sum(d_2to1))
  
  new_row1<-matrix(data=c(last_row1+change_1),ncol = 4, dimnames = list(paste("Year_",year,sep=""),colnames(matrix1)))
  new_row2<-matrix(data=c(last_row2+change_2),ncol = 4, dimnames = list(paste("Year_",year,sep=""),colnames(matrix1)))
  return(list(row1=new_row1,row2=new_row2))
}
```
#Gamete Production Individual
Model the gamete production of one individual. Parameters:

Patch - to see how well-fitted the individual is
Genotype - [A,B,M]<-AA,BB,Mixed:AB, to see what kind of gametes the individual can produce,
           and to check for fitness.
f_max - how many gametes the individual would produce under optimal circumstances.
h     - dominance coefficient, default set to 0.5
s     - selection coefficient

Output: a list/vector containing alleles eg.:c("A","A","A","A","A","B","B","B","B","B")
```{r Gamete Individual}

```
#Gamete Production population: 
models the gamete production of one entire population, produces list of gametes.Parameters:

Patch - which patch, has to be given to gamete individual
Genotypes - a ratio, than in combination with number of indiviuals, or a count for all genotypes

Output: an aggregated list/vector of all Gametes
```{r Gamete Population}
gamete_production<-function(matrix, parameters, year,N_new, method="default", ...){
unfavored<-ifelse(parameters$favored=="AA", "BB","AA")
favored<-parameters$favored
prob_unfavored<-(1-parameters$s)
prob_heterozygen<-(1-parameters$h*parameters$s)
prob_favored<-1
fmax<-N_new/prob_unfavored
favored_mult<-ceiling(matrix[,favored]*prob_favored)
unfavored_mult<-ceiling(matrix[,unfavored]*prob_unfavored)
heterozygen_mult<-ceiling(matrix[,"AB"]*prob_heterozygen)
gamete_vector<-rep(substr(favored,1,1),times=(2*favored_mult))
gamete_vector<-c(gamete_vector,rep(substr(unfavored,1,1),times=(2*unfavored_mult)))
gamete_vector<-c(gamete_vector,rep("A",heterozygen_mult),rep("B",heterozygen_mult))
print(fmax)
return(gamete_vector)
}
```
#Fusion
models the fusion of gametes in one patch. Parameters:

Gamete_List - a vector/list of gametes, from which two gametes are randomly sampled until N individuals are created reached. 
N - number of individuals that should be in the patch at the end

Output: 3 numbers, describing the number of individuals in a patch with the genotypes A,B,M
```{r Fusion}
test_vector<-c("A","A","A","A","A","B","B","B","B","B","A","A","A","A","A","B","B","B","B","B","A","A","A","A","A","B","B","B","B","B")
test_N<-12

Fusion<-function(gamete_vector=test_vector,N=test_N){ 
  A<-0
  B<-0
  M<-0
  num_gametes<-length(gamete_vector)
  
  ifelse(N*2>num_gametes,
    final_gametes<-gamete_vector[sample(num_gametes)],     
    final_gametes<-gamete_vector[sample(num_gametes,size=N*2,replace=FALSE)])
  
  for (i in seq(1,length(final_gametes)-1,2)){
    first<-final_gametes[i]
    second<-final_gametes[i+1]
    ifelse(first==second,
           ifelse(first=="A",
                  A<-A+1,
                  B<-B+1),
           M<-M+1)
  }
  return(c(A,B,M))
}
```

#Set-up
initialize two lists, both containing a matrix, and a list of parameters
N0 should be dividable by 4.

```{r}
#Set values for selection_coefficient, heterozygote_coefficient, if they are symmetrical
selection_coefficient <- 0.8
heterozygote_coefficient <-0.4

para_patch1<-list(N0=360, b=0.001, l_max=1.4, 
                  wanderlust=1.1, dispersal_prob=0.2,
                  favored="AA", s=selection_coefficient,h=heterozygote_coefficient)
para_patch2<-list(N0=40, b=0.001, l_max=1.4,
                  wanderlust=0.7, dispersal_prob=0.1,
                  favored="BB", s=selection_coefficient,h=heterozygote_coefficient)

matrix_patch1<-matrix(data=c(para_patch1$N0/4,para_patch1$N0/2,para_patch1$N0/4,para_patch1$N0),ncol=4,dimnames = list(c("Year_0"),c("AA","AB","BB","overall")))

matrix_patch2<-matrix(data=c(para_patch2$N0/4,para_patch2$N0/2,para_patch2$N0/4,para_patch2$N0),ncol=4,dimnames = list(c("Year_0"),c("AA","AB","BB","overall")))

Patch_1_list<-list(parameters=para_patch1, matrix=matrix_patch1)
Patch_2_list<-list(parameters=para_patch1, matrix=matrix_patch2)
```

#Combined
models, given a number of years, the number of individuals of different genotypes in each patch. Parameters:

years - number of years to model
table - a table to fill with data
...   - all parameters used in subsequent called functions
```{r Combined}

for(i in 1:50){
  disp_result<-dispersal(Patch_1_list$matrix,Patch_2_list$matrix, Patch_1_list$parameters, Patch_2_list$parameters, year=i,method="even", random=TRUE)
  Patch_1_list$matrix<-rbind(Patch_1_list$matrix,disp_result$row1)
  Patch_2_list$matrix<-rbind(Patch_2_list$matrix,disp_result$row2)
  
}
View(Patch_2_list$matrix)
View(Patch_1_list$matrix)
```
- Es gibt nur einen Patch, bei dem überhaupt gejagt wird/die Population kurzzeitig stark eingeschränkt sein kann.
- Unterschiedlich große Patches
- Dispersion von Individuen, bevor die Anzahl auf N1/N2 getrimmt wird.
- Variable Parameter für Populationsentwicklung 
- Dispersion rate könnte von Gesamtmenge im Patch abhängen
